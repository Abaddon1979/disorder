<script type="text/discourse-plugin" version="0.8.7">
console.log("[Discord Style Chat] Plugin loaded");

let fetchTimer = null;
let onlineUsernames = new Set();

api.onPageChange(() => {
  const { ajax } = require("discourse/lib/ajax");
  const sidebarEnabled = (settings.enable_online_sidebar !== false);
  const sidebarWidth = settings.sidebar_width || 240;
  const refreshInterval = settings.user_refresh_interval || 30000;
  const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const isNarrowDesktop = window.innerWidth <= 1024 && !isMobileUA;
  const isMobile = isMobileUA;

  if (!sidebarEnabled) return;
  if (isNarrowDesktop) return;
  
  const isChatPage = window.location.pathname.includes('/chat') || document.querySelector('.full-page-chat, .chat-drawer');
  
  if (!isChatPage) {
    // Ensure any chat context menu is removed when leaving chat
    const existingMenu = document.querySelector('.discord-chat-context-menu');
    if (existingMenu) {
      existingMenu.remove();
    }

    const existing = document.getElementById('discord-online-users-sidebar');
    if (existing) existing.remove();
    const mobileDrawer = document.getElementById('discord-online-users-drawer');
    if (mobileDrawer) mobileDrawer.remove();
    const mobileOverlay = document.getElementById('discord-mobile-drawer-overlay');
    if (mobileOverlay) mobileOverlay.remove();
    document.body.classList.remove("enable-online-sidebar", "mobile-drawer-open");
    document.documentElement.style.removeProperty('--sidebar-width');
    if (fetchTimer) {
      clearInterval(fetchTimer);
      fetchTimer = null;
    }
    return;
  }

  if (!isMobile) {
    document.documentElement.style.setProperty('--sidebar-width', sidebarWidth + 'px');
    document.body.classList.add("enable-online-sidebar");
  }

  function showUserCard(username, event) {
    document.querySelectorAll('.discord-user-card-backdrop, .discord-user-card').forEach(el => el.remove());
    
    const backdrop = document.createElement('div');
    backdrop.className = 'discord-user-card-backdrop';
    backdrop.onclick = () => document.querySelectorAll('.discord-user-card-backdrop, .discord-user-card').forEach(el => el.remove());
    
    const card = document.createElement('div');
    card.className = 'discord-user-card';
    
    const clickX = (event && typeof event.clientX === "number") ? event.clientX : window.innerWidth / 2;
    const clickY = (event && typeof event.clientY === "number") ? event.clientY : window.innerHeight / 2;
    const cardWidth = 600;
    const cardHeight = 280;
    
    if (isMobile) {
      // Full-screen mobile card; positioning handled by CSS
      card.style.left = '0';
      card.style.top = '0';
    } else {
      let left = clickX + 10;
      if (left + cardWidth > window.innerWidth) left = clickX - cardWidth - 10;
      let top = clickY + 10;
      if (top + cardHeight > window.innerHeight) top = Math.max(10, clickY - cardHeight - 10);
      
      card.style.left = left + 'px';
      card.style.top = top + 'px';
    }
    card.innerHTML = '<button class="user-card-close">√ó</button><div class="user-card-left"><div class="user-card-loading"><div class="spinner"></div><span>Loading...</span></div></div><div class="user-card-right"></div>';
    
    document.body.appendChild(backdrop);
    document.body.appendChild(card);
    
    const closeBtn = card.querySelector('.user-card-close');
    closeBtn.onclick = (e) => { e.stopPropagation(); document.querySelectorAll('.discord-user-card-backdrop, .discord-user-card').forEach(el => el.remove()); };
    
    ajax("/u/" + username + ".json").then(data => {
      const user = data.user;
      const avatar = (user.avatar_template.startsWith('/') ? window.location.origin : '') + user.avatar_template.replace('{size}', '256');
      const leftSection = card.querySelector('.user-card-left');
      const rightSection = card.querySelector('.user-card-right');
      if (!leftSection || !rightSection) return;
      
      const savedBg = localStorage.getItem('user_card_bg_' + username);
      if (savedBg) {
        card.style.setProperty('--user-card-bg', 'url(' + savedBg + ')');
        card.setAttribute('data-bg-url', savedBg);
      }
      
      const rolesHTML = user.groups && user.groups.length > 0 ? '<div class="roles-section"><div class="section-title">Roles</div><div class="roles-list">' + user.groups.slice(0, 4).map(g => '<a href="/g/' + g.name + '" class="role-chip">' + (g.display_name || g.name) + '</a>').join('') + '</div>' + (user.badge_count ? '<div class="badge-count">üèÖ ' + user.badge_count + ' badges</div>' : '') + '</div>' : (user.badge_count ? '<div class="roles-section"><div class="badge-count">üèÖ ' + user.badge_count + ' badges</div></div>' : '');
      
      const editIconSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>';
      
      const savedStatus = user.chat_status || "";
      const apiCurrentUser = api.getCurrentUser ? api.getCurrentUser() : null;
      const currentUsername =
        (window.currentUser && window.currentUser.username) ||
        (apiCurrentUser && apiCurrentUser.username) ||
        null;
      const isOwnProfile = !!currentUsername && user.username === currentUsername;
      const editButtonHTML = isOwnProfile ? '<button class="edit-background-btn" title="Change Background">' + editIconSVG + '</button>' : '';
      const channelId = (user.id || 0);
      
      leftSection.innerHTML =
        '<div class="user-card-avatar">' +
          '<img src="' + avatar + '" alt="' + user.username + ' avatar">' +
          '<div class="status-badge"></div>' +
          editButtonHTML +
        '</div>' +
        '<div class="user-info">' +
          '<div class="name-stack">' +
            '<h2 class="display-name">' + (user.name || user.username) + '</h2>' +
            '<p class="username">@' + user.username + '</p>' +
          '</div>' +
          '<div class="posts-stat">' +
            '<span class="stat-value">' + (user.post_count || 0) + '</span>' +
            '<span class="stat-label">Posts</span>' +
          '</div>' +
        '</div>' +
        rolesHTML;
      
      rightSection.innerHTML = '<div class="status-box"><div class="status-label">Status</div><textarea placeholder="' + (isOwnProfile ? 'Set your status...' : 'User status...') + '" ' + (isOwnProfile ? '' : 'readonly disabled') + '>' + savedStatus + '</textarea></div><div class="user-actions"><a href="#" class="btn btn-primary user-card-chat-btn">üí¨ Chat</a><a href="/new-message?username=' + user.username + '" class="btn btn-secondary">‚úâÔ∏è Message</a><a href="/u/' + user.username + '" class="btn btn-secondary">üë§ Profile</a></div>';
      
      const chatBtn = rightSection.querySelector('.user-card-chat-btn');

      if (chatBtn) {
        chatBtn.onclick = async (e) => {
          e.preventDefault();
          e.stopPropagation();

          try {
            // Resolve services at click-time to avoid timing issues
            const container =
              api.container ||
              (window.Discourse && window.Discourse.__container__) ||
              null;

            const chatService =
              container && container.lookup
                ? container.lookup("service:chat")
                : null;
            const router =
              container && container.lookup
                ? container.lookup("service:router")
                : null;

            if (!chatService) {
              console.error("Chat service not available, cannot open DM channel");
              return;
            }

            const channel = await chatService.upsertDmChannel({
              usernames: [user.username],
            });

            // Debug: inspect the full response from upsertDmChannel / direct-message-channels.json
            console.log("[Discord Style Chat] DM channel response:", channel);

            // Channel info is under `channel`, as in:
            // { "channel": { "id": 1843, ... } }
            const dmChannel = channel && channel.channel ? channel.channel : channel;

            if (dmChannel && dmChannel.id) {
              const dmUrl =
                "/chat/c/" +
                encodeURIComponent(user.username) +
                "/" +
                dmChannel.id;
              console.log("[Discord Style Chat] Navigating to DM URL:", dmUrl);
              window.location.href = dmUrl;
            } else {
              console.error(
                "[Discord Style Chat] Could not resolve DM channel id from response:",
                channel
              );
            }

            document
              .querySelectorAll(".discord-user-card-backdrop, .discord-user-card")
              .forEach((el) => el.remove());
          } catch (error) {
            console.error("Failed to open chat:", error);
          }
        };
      }
      
      const editBtn = card.querySelector('.edit-background-btn');
      if (editBtn && isOwnProfile) {
        editBtn.onclick = (e) => {
          e.stopPropagation();
          openTenorPicker(username, card);
        };
      }
      
      // Save status whenever the card is closed, either by X button or clicking the backdrop
      const handleCardClose = (e) => {
        e.stopPropagation();

        if (isOwnProfile) {
          const statusTextarea = card.querySelector(".status-box textarea");
          if (statusTextarea) {
            const newStatus = statusTextarea.value || "";
            ajax("/chat-status.json", {
              type: "PUT",
              data: { status: newStatus },
            }).catch((err) => {
              console.error(
                "[Discord Style Chat] Failed to update status on close",
                err
              );
            });
          }
        }

        document
          .querySelectorAll(
            ".discord-user-card-backdrop, .discord-user-card"
          )
          .forEach((el) => el.remove());
      };

      closeBtn.onclick = handleCardClose;
      backdrop.onclick = handleCardClose;
    });
  }

  function openTenorPicker(username, cardElement) {
    const modal = document.createElement('div');
    modal.className = 'tenor-picker-modal';
    modal.innerHTML = '<div class="tenor-header"><h3>Select Animated Background</h3><button class="tenor-close">√ó</button></div><div class="tenor-search"><input type="text" placeholder="Search for GIFs..." class="tenor-search-input"></div><div class="tenor-results"></div>';
    document.body.appendChild(modal);
    
    const closeBtn = modal.querySelector('.tenor-close');
    const searchInput = modal.querySelector('.tenor-search-input');
    const resultsDiv = modal.querySelector('.tenor-results');
    closeBtn.onclick = () => modal.remove();
    
    function searchTenor(query) {
      const url = `https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(query || 'anime aesthetic')}&key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&limit=30&media_filter=gif,webp`;
      fetch(url).then(r => r.json()).then(data => {
        resultsDiv.innerHTML = '';
        if (data.results) {
          data.results.forEach(gif => {
            const img = document.createElement('img');
            img.src = gif.media_formats.tinygif?.url || gif.media_formats.gif.url;
            img.dataset.fullUrl = gif.media_formats.webp?.url || gif.media_formats.gif?.url;
            img.onclick = () => {
              const fullUrl = img.dataset.fullUrl;
              cardElement.style.setProperty('--user-card-bg', 'url(' + fullUrl + ')');
              cardElement.setAttribute('data-bg-url', fullUrl);
              // Persist locally for quick load
              localStorage.setItem('user_card_bg_' + username, fullUrl);
              // Persist on server so everyone sees the same background
              ajax("/chat-status.json", {
                type: "PUT",
                data: { background_url: fullUrl },
              }).catch((e) => {
                console.error("[Discord Style Chat] Failed to update background_url", e);
              });
              modal.remove();
            };
            resultsDiv.appendChild(img);
          });
        }
      }).catch(err => { resultsDiv.innerHTML = '<p style="color:#dcddde;text-align:center;padding:20px;">Failed to load GIFs.</p>'; });
    }
    
    searchTenor('');
    let searchTimeout;
    searchInput.addEventListener('input', (e) => { clearTimeout(searchTimeout); searchTimeout = setTimeout(() => searchTenor(e.target.value), 500); });
  }

  function updateOnlineStatus() {
    if (isMobile) {
      createMobileDrawer();
    } else {
      createSidebar();
    }
  }

  function updateSidebarPosition() {
    const sidebar = document.getElementById('discord-online-users-sidebar');
    if (!sidebar) return;
    const header = document.querySelector('.d-header');
    let headerHeight = 60;

    if (header) {
      headerHeight = header.offsetHeight || 60;
    }

    sidebar.style.top = headerHeight + 'px';
    sidebar.style.height = 'calc(100vh - ' + headerHeight + 'px)';
    document.documentElement.style.setProperty('--discord-header-height', headerHeight + 'px');
  }

  function createSidebar() {
    const existing = document.getElementById('discord-online-users-sidebar');
    if (existing) existing.remove();
    
    const sidebar = document.createElement('div');
    sidebar.id = 'discord-online-users-sidebar';
    sidebar.className = 'discord-sidebar';
    sidebar.style.cssText = 'position:fixed!important;right:0!important;width:' + sidebarWidth + 'px!important;background:#19191d!important;border-left:1px solid #202225!important;z-index:999!important;overflow-y:auto!important;display:block!important;';
    sidebar.innerHTML = '<div class="discord-sidebar-header" style="padding:16px;border-bottom:1px solid #202225;"><h3 style="color:#8e9297;font-size:12px;font-weight:600;margin:0;">Users ‚Äî <span class="online-count">0</span></h3></div><div class="discord-sidebar-users loading" style="padding:8px;"></div>';
    document.body.appendChild(sidebar);
    updateSidebarPosition();

    ajax("/sideonline.json").then(data => {
      const allUsers = data.users || [];
      onlineUsernames = new Set(allUsers.map(u => u.username));
      const container = document.querySelector('.discord-sidebar-users');
      const count = document.querySelector('.online-count');
      if (!container) return;
      container.classList.remove('loading');
      
      const admins = [], moderators = [], onlineTL4 = [], onlineTL3 = [], onlineTL2 = [], onlineTL1 = [], onlineTL0 = [];
      allUsers.forEach(user => {
        if (user.admin) admins.push(user);
        else if (user.moderator) moderators.push(user);
        else {
          const tl = user.trust_level || 0;
          if (tl === 4) onlineTL4.push(user);
          else if (tl === 3) onlineTL3.push(user);
          else if (tl === 2) onlineTL2.push(user);
          else if (tl === 1) onlineTL1.push(user);
          else onlineTL0.push(user);
        }
      });
      
      let html = '';
      if (admins.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#e74c3c;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Administrators ‚Äî ' + admins.length + '</div>';
        admins.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (moderators.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#f39c12;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Moderators ‚Äî ' + moderators.length + '</div>';
        moderators.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL4.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#9b59b6;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Trust Level 4 ‚Äî ' + onlineTL4.length + '</div>';
        onlineTL4.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL3.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#1abc9c;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Trust Level 3 ‚Äî ' + onlineTL3.length + '</div>';
        onlineTL3.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL2.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#95a5a6;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Trust Level 2 ‚Äî ' + onlineTL2.length + '</div>';
        onlineTL2.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL1.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#7f8c8d;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Trust Level 1 ‚Äî ' + onlineTL1.length + '</div>';
        onlineTL1.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL0.length > 0) {
        html += '<div class="role-group"><div class="role-header" style="color:#5f6c6d;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;padding:12px 8px 4px 8px;">Trust Level 0 ‚Äî ' + onlineTL0.length + '</div>';
        onlineTL0.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      
      container.innerHTML = html;
      container.querySelectorAll('.discord-user-item').forEach(item => {
        item.onmouseenter = () => item.style.backgroundColor = '#3c3f45';
        item.onmouseleave = () => item.style.backgroundColor = 'transparent';
        item.onclick = (e) => { e.preventDefault(); e.stopPropagation(); showUserCard(item.dataset.username, e); };
      });
      count.textContent = allUsers.length;
    });
  }

  function renderUser(user) {
    const avatar = (user.avatar_template.startsWith('/') ? window.location.origin : '') + user.avatar_template.replace('{size}', '96');
    return '<div class="discord-user-item online" data-username="' + user.username + '" style="display:flex;align-items:center;padding:8px;margin:2px 0;border-radius:4px;cursor:pointer;"><div style="width:32px;height:32px;margin-right:12px;position:relative;"><img src="' + avatar + '" style="width:100%;height:100%;border-radius:50%;"><div class="status-dot" style="position:absolute;bottom:-2px;right:-2px;width:12px;height:12px;background:#43b581;border:3px solid #2f3136;border-radius:50%;"></div></div><div style="flex:1;"><div style="color:#dcddde;font-size:14px;font-weight:500;">' + user.username + '</div></div></div>';
  }

  function createMobileDrawer() {
    let drawer = document.getElementById('discord-online-users-drawer');
    if (!drawer) {
      drawer = document.createElement('div');
      drawer.id = 'discord-online-users-drawer';
      drawer.className = 'discord-mobile-drawer';
      drawer.innerHTML = '<div class="discord-mobile-drawer-header"><h3>Users ‚Äî <span class="online-count">0</span></h3><button class="drawer-close">√ó</button></div><div class="discord-mobile-drawer-users loading"></div>';
      document.body.appendChild(drawer);

      let overlay = document.getElementById('discord-mobile-drawer-overlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'discord-mobile-drawer-overlay';
        overlay.className = 'discord-mobile-drawer-overlay';
        overlay.onclick = () => {
          document.body.classList.remove('mobile-drawer-open');
        };
        document.body.appendChild(overlay);
      }

      const closeBtn = drawer.querySelector('.drawer-close');
      if (closeBtn) {
        closeBtn.onclick = () => {
          document.body.classList.remove('mobile-drawer-open');
        };
      }
    }

    ajax("/sideonline.json").then(data => {
      const allUsers = data.users || [];
      onlineUsernames = new Set(allUsers.map(u => u.username));
      const container = drawer.querySelector('.discord-mobile-drawer-users');
      const count = drawer.querySelector('.online-count');
      if (!container) return;
      container.classList.remove('loading');

      const admins = [], moderators = [], onlineTL4 = [], onlineTL3 = [], onlineTL2 = [], onlineTL1 = [], onlineTL0 = [];
      allUsers.forEach(user => {
        if (user.admin) admins.push(user);
        else if (user.moderator) moderators.push(user);
        else {
          const tl = user.trust_level || 0;
          if (tl === 4) onlineTL4.push(user);
          else if (tl === 3) onlineTL3.push(user);
          else if (tl === 2) onlineTL2.push(user);
          else if (tl === 1) onlineTL1.push(user);
          else onlineTL0.push(user);
        }
      });

      let html = '';
      if (admins.length > 0) {
        html += '<div class="role-group"><div class="role-header">Administrators ‚Äî ' + admins.length + '</div>';
        admins.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (moderators.length > 0) {
        html += '<div class="role-group"><div class="role-header">Moderators ‚Äî ' + moderators.length + '</div>';
        moderators.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL4.length > 0) {
        html += '<div class="role-group"><div class="role-header">Trust Level 4 ‚Äî ' + onlineTL4.length + '</div>';
        onlineTL4.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL3.length > 0) {
        html += '<div class="role-group"><div class="role-header">Trust Level 3 ‚Äî ' + onlineTL3.length + '</div>';
        onlineTL3.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL2.length > 0) {
        html += '<div class="role-group"><div class="role-header">Trust Level 2 ‚Äî ' + onlineTL2.length + '</div>';
        onlineTL2.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL1.length > 0) {
        html += '<div class="role-group"><div class="role-header">Trust Level 1 ‚Äî ' + onlineTL1.length + '</div>';
        onlineTL1.forEach(u => html += renderUser(u));
        html += '</div>';
      }
      if (onlineTL0.length > 0) {
        html += '<div class="role-group"><div class="role-header">Trust Level 0 ‚Äî ' + onlineTL0.length + '</div>';
        onlineTL0.forEach(u => html += renderUser(u));
        html += '</div>';
      }

      container.innerHTML = html;
      container.querySelectorAll('.discord-user-item').forEach(item => {
        item.onmouseenter = null;
        item.onmouseleave = null;
        item.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          showUserCard(item.dataset.username, e);
          document.body.classList.remove('mobile-drawer-open');
        };
      });
      if (count) {
        count.textContent = allUsers.length;
      }
    });
  }

  function setupMobileDrawerGestures() {
    const chatArea = document.querySelector('.chat-container, .chat-drawer-container, .full-page-chat');
    if (!chatArea || chatArea.dataset.mobileDrawerGestures === "true") return;

    chatArea.dataset.mobileDrawerGestures = "true";

    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const THRESHOLD = 60;

    chatArea.addEventListener('touchstart', function (e) {
      if (!e.touches || e.touches.length !== 1) return;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      touchEndX = touchStartX;
      touchEndY = touchStartY;
    }, { passive: true });

    chatArea.addEventListener('touchmove', function (e) {
      if (!e.touches || e.touches.length !== 1) return;
      touchEndX = e.touches[0].clientX;
      touchEndY = e.touches[0].clientY;
    }, { passive: true });

    chatArea.addEventListener('touchend', function () {
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      if (Math.abs(deltaX) < THRESHOLD || Math.abs(deltaY) > 80) return;

      if (deltaX < -THRESHOLD) {
        document.body.classList.add('mobile-drawer-open');
        createMobileDrawer();
      } else if (deltaX > THRESHOLD) {
        document.body.classList.remove('mobile-drawer-open');
      }
    });
  }

  // Discord-style chat right-click context menu (only for chat messages, not sidebar)
  function hideChatContextMenu() {
    const menu = document.querySelector(".discord-chat-context-menu");
    if (menu) {
      menu.classList.remove("is-visible");
      // Small delay before removing to allow CSS transition if desired
      menu.remove();
    }
    document.body.classList.remove("discord-chat-context-open");
  }

  function buildChatContextMenuContent({ type, username, messageId, messageEl }) {
    const items = [];

    if (type === "user" && username) {
      // Right-click on a username in chat
      items.push({
        label: "Profile",
        action: "profile",
      });
      items.push({
        label: "Chat DM",
        action: "chat-dm",
      });
      items.push({
        label: "Forum DM",
        action: "forum-dm",
      });
      items.push({
        label: "Mention",
        action: "mention",
      });
      items.push({
        label: "Add Note",
        action: "add-note",
      });
    } else if (type === "message") {
      // Right-click on a chat message
      items.push({
        label: "Add Reaction",
        action: "react",
      });
      items.push({
        label: "Reply",
        action: "reply",
      });
      items.push({
        label: "Copy text",
        action: "copy-message",
      });
      items.push({
        label: "üö© Report Message",
        action: "report",
      });
    }

    // Fallback in case we somehow ended up without items
    if (!items.length) {
      items.push({
        label: "No actions available",
        action: "noop",
        disabled: true,
      });
    }

    let html = '<ul class="discord-chat-context-menu__list">';
    items.forEach((item) => {
      const disabledClass = item.disabled ? " is-disabled" : "";
      html +=
        '<li class="discord-chat-context-menu__item' +
        disabledClass +
        '" data-action="' +
        (item.action || "") +
        '">' +
        item.label +
        "</li>";
    });
    html += "</ul>";
    return html;
  }

  function showChatContextMenu(event, { type, username, messageId, messageEl }) {
    hideChatContextMenu();
    event.preventDefault();
    event.stopPropagation();

    const menu = document.createElement("div");
    menu.className = "discord-chat-context-menu";
    menu.dataset.contextType = type || "";
    if (username) {
      menu.dataset.username = username;
    }
    if (messageId) {
      menu.dataset.messageId = messageId;
    }

    menu.innerHTML = buildChatContextMenuContent({
      type,
      username,
      messageId,
      messageEl,
    });

    document.body.appendChild(menu);
    document.body.classList.add("discord-chat-context-open");

    // Position the menu near the cursor, adjusting for viewport edges
    const clickX = event.clientX;
    const clickY = event.clientY;
    const menuRect = menu.getBoundingClientRect();
    let left = clickX;
    let top = clickY;

    if (left + menuRect.width > window.innerWidth) {
      left = Math.max(0, window.innerWidth - menuRect.width - 4);
    }
    if (top + menuRect.height > window.innerHeight) {
      top = Math.max(0, window.innerHeight - menuRect.height - 4);
    }

    menu.style.left = left + "px";
    menu.style.top = top + "px";

    // Handle menu item clicks
    menu.addEventListener("click", function (e) {
      const item = e.target.closest(".discord-chat-context-menu__item");
      if (!item || item.classList.contains("is-disabled")) {
        return;
      }
      const action = item.dataset.action;
      const uname = menu.dataset.username || username || "";
      const msgId = menu.dataset.messageId || messageId || "";
      const msgElement = messageEl;

      // Simple helpers
      function copyToClipboard(text) {
        if (!text) return;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).catch(function (err) {
            console.error("[Discord Style Chat] Failed to copy text", err);
          });
        } else {
          const temp = document.createElement("textarea");
          temp.value = text;
          document.body.appendChild(temp);
          temp.select();
          try {
            document.execCommand("copy");
          } catch (e) {
            console.error("[Discord Style Chat] execCommand copy failed", e);
          }
          document.body.removeChild(temp);
        }
      }

      if (action === "profile" && uname) {
        // Open forum profile
        window.location.href = "/u/" + encodeURIComponent(uname);
      } else if (action === "chat-dm" && uname) {
        // Open chat DM channel
        (async function () {
          try {
            const container =
              api.container ||
              (window.Discourse && window.Discourse.__container__) ||
              null;
            const chatService =
              container && container.lookup
                ? container.lookup("service:chat")
                : null;
            if (!chatService) {
              console.error(
                "[Discord Style Chat] Chat service not available for DM from context menu"
              );
              return;
            }
            const channel = await chatService.upsertDmChannel({
              usernames: [uname],
            });
            const dmChannel =
              channel && channel.channel ? channel.channel : channel;
            if (dmChannel && dmChannel.id) {
              const dmUrl =
                "/chat/c/" + encodeURIComponent(uname) + "/" + dmChannel.id;
              window.location.href = dmUrl;
            }
          } catch (err) {
            console.error("[Discord Style Chat] Failed to open DM", err);
          }
        })();
      } else if (action === "forum-dm" && uname) {
        // Open classic forum PM composer
        window.location.href =
          "/new-message?username=" + encodeURIComponent(uname);
      } else if (action === "mention" && uname) {
        // Insert @mention into composer if available
        const composerInput =
          document.querySelector(".chat-composer textarea") ||
          document.querySelector(".chat-composer-input textarea") ||
          document.querySelector(".chat-composer-input");
        if (composerInput) {
          const atMention = "@" + uname + " ";
          if (
            typeof composerInput.selectionStart === "number" &&
            typeof composerInput.selectionEnd === "number"
          ) {
            const start = composerInput.selectionStart;
            const end = composerInput.selectionEnd;
            const value = composerInput.value || "";
            composerInput.value =
              value.slice(0, start) + atMention + value.slice(end);
            composerInput.selectionStart = composerInput.selectionEnd =
              start + atMention.length;
          } else {
            composerInput.value = (composerInput.value || "") + atMention;
          }
          composerInput.focus();
        }
      } else if (action === "add-note" && uname) {
        // Open local-only note editor for this user
        openUserNoteEditor(uname);
      } else if (action === "copy-username" && uname) {
        copyToClipboard(uname);
      } else if (action === "copy-message" && msgElement) {
        const textEl =
          msgElement.querySelector(".chat-message-text") || msgElement;
        copyToClipboard(textEl.textContent.trim());
      } else if (action === "copy-link" && msgId) {
        // Best-effort message link; Discourse chat uses /chat/channel/:id?messageId=:messageId
        const channelIdEl = document.querySelector(
          ".chat-channel-header, .chat-header"
        );
        let channelId = "";
        if (channelIdEl && channelIdEl.dataset && channelIdEl.dataset.channelId) {
          channelId = channelIdEl.dataset.channelId;
        }
        const url =
          window.location.origin +
          (channelId
            ? "/chat/channel/" +
              encodeURIComponent(channelId) +
              "?messageId=" +
              encodeURIComponent(msgId)
            : window.location.pathname +
              (window.location.search
                ? window.location.search + "&"
                : "?") +
              "messageId=" +
              encodeURIComponent(msgId));
        copyToClipboard(url);
      } else if (action === "reply" && msgElement) {
        // Try to trigger Discourse's built-in reply button for this message
        const replyBtn =
          msgElement.querySelector(".chat-message-reply") ||
          msgElement.querySelector('[data-action="reply"]');
        if (replyBtn && replyBtn.click) {
          replyBtn.click();
        }
      } else if (action === "react" && msgElement) {
        // Try to open the built-in reaction picker for this message
        const reactBtn =
          msgElement.querySelector(
            ".chat-message-reaction, .chat-message-react, [data-action=\"react\"], .chat-message-actions__button--react"
          );
        if (reactBtn && reactBtn.click) {
          reactBtn.click();
        }
      } else if (action === "report" && msgElement) {
        // Try to trigger the built-in flag / report action for this message
        const reportBtn =
          msgElement.querySelector(
            ".chat-message-flag, [data-action=\"flag\"], [data-action=\"report\"]"
          );
        if (reportBtn && reportBtn.click) {
          reportBtn.click();
        }
      }

      hideChatContextMenu();
    });

    // Show with a small fade-in class
    requestAnimationFrame(function () {
      menu.classList.add("is-visible");
    });
  }

  function refreshUserNoteIndicators() {
    // Chat messages: add/remove note icon next to usernames
    const usernameSelectors =
      ".chat-message-info .username, .chat-message-username, .chat-message-author, .chat-message-user, [data-user-card], [data-username]";
    const nameEls = document.querySelectorAll(usernameSelectors);
    nameEls.forEach((el) => {
      let uname =
        (el.dataset && (el.dataset.userCard || el.dataset.username)) ||
        (el.textContent || "").trim().replace(/^@/, "");
      if (!uname) {
        return;
      }

      const key = "discord_user_note_" + uname;
      const stored = localStorage.getItem(key);
      const hasNote = !!(stored && stored.trim());

      const infoEl =
        el.closest(".chat-message-info, .chat-message-header") ||
        el.parentElement;
      if (!infoEl) {
        return;
      }

      let icon = infoEl.querySelector(
        '.discord-note-indicator[data-username="' + uname + '"]'
      );

      if (hasNote) {
        if (!icon) {
          icon = document.createElement("span");
          icon.className = "discord-note-indicator";
          icon.dataset.username = uname;
          icon.title = "You have a personal note for @" + uname;
          icon.textContent = "üìù";

          const timeEl = infoEl.querySelector(
            ".time, .chat-message-time, .chat-message-metadata__time"
          );
          const anchor = timeEl || el;
          anchor.insertAdjacentElement("afterend", icon);
        }
      } else if (icon) {
        icon.remove();
      }
    });

    // Sidebar / mobile drawer: add/remove icon at end of user row
    const sidebarItems = document.querySelectorAll(".discord-user-item");
    sidebarItems.forEach((item) => {
      const uname =
        item.dataset.username ||
        item.getAttribute("data-username") ||
        (item.textContent || "").trim();
      if (!uname) {
        return;
      }

      const key = "discord_user_note_" + uname;
      const stored = localStorage.getItem(key);
      const hasNote = !!(stored && stored.trim());

      let icon = item.querySelector(
        '.discord-note-indicator[data-username="' + uname + '"]'
      );

      if (hasNote) {
        if (!icon) {
          icon = document.createElement("span");
          icon.className = "discord-note-indicator";
          icon.dataset.username = uname;
          icon.title = "You have a personal note for @" + uname;
          icon.textContent = "üìù";
          item.appendChild(icon);
        }
      } else if (icon) {
        icon.remove();
      }
    });
  }

  function setupUserNoteObserver() {
    const container =
      document.querySelector(".chat-messages-container") ||
      document.querySelector(".chat-messages-scroller");
    if (!container || container.__discordNoteObserver) {
      return;
    }

    const observer = new MutationObserver(() => {
      refreshUserNoteIndicators();
    });

    observer.observe(container, {
      childList: true,
      subtree: true,
    });

    container.__discordNoteObserver = observer;
  }

  function openUserNoteEditor(username) {
    // Remove any existing note modal
    document
      .querySelectorAll(".discord-note-modal-backdrop, .discord-note-modal")
      .forEach((el) => el.remove());

    const existingNote =
      localStorage.getItem("discord_user_note_" + username) || "";

    const backdrop = document.createElement("div");
    backdrop.className = "discord-note-modal-backdrop";

    const modal = document.createElement("div");
    modal.className = "discord-note-modal";
    modal.innerHTML =
      '<div class="discord-note-modal-header">' +
      '<h3>Personal Note for @' +
      username +
      "</h3>" +
      "</div>" +
      '<div class="discord-note-modal-body">' +
      '<textarea rows="6" placeholder="Write a note only you can see..."></textarea>' +
      "</div>" +
      '<div class="discord-note-modal-footer">' +
      '<button class="discord-note-cancel">Cancel</button>' +
      '<button class="discord-note-save">Save</button>' +
      "</div>";

    document.body.appendChild(backdrop);
    document.body.appendChild(modal);

    const textarea = modal.querySelector("textarea");
    const cancelBtn = modal.querySelector(".discord-note-cancel");
    const saveBtn = modal.querySelector(".discord-note-save");

    if (textarea) {
      textarea.value = existingNote;
      textarea.focus();
    }

    function closeNoteModal() {
      document
        .querySelectorAll(".discord-note-modal-backdrop, .discord-note-modal")
        .forEach((el) => el.remove());
    }

    backdrop.onclick = function () {
      closeNoteModal();
    };

    if (cancelBtn) {
      cancelBtn.onclick = function (e) {
        e.preventDefault();
        e.stopPropagation();
        closeNoteModal();
      };
    }

    if (saveBtn) {
      saveBtn.onclick = function (e) {
        e.preventDefault();
        e.stopPropagation();
        const newValue = textarea ? textarea.value.trim() : "";
        const key = "discord_user_note_" + username;

        if (newValue) {
          localStorage.setItem(key, newValue);
        } else {
          localStorage.removeItem(key);
        }

        closeNoteModal();
        // Update any visible note icons for this user
        refreshUserNoteIndicators();
      };
    }
  }

  function setupChatContextMenu() {
    if (window.__discordChatContextMenuInitialized) {
      return;
    }
    window.__discordChatContextMenuInitialized = true;

    // Global contextmenu handler, but restrict strictly to chat messages
    document.addEventListener(
      "contextmenu",
      function (e) {
        const target = e.target;

        // Ignore if right-click is inside our custom menu
        if (target.closest && target.closest(".discord-chat-context-menu")) {
          return;
        }

        // Only respond when in a chat context
        const isInChat =
          document.querySelector(".chat-container, .chat-drawer, .full-page-chat") !==
          null;
        if (!isInChat) {
          return;
        }

        const messageEl = target.closest
          ? target.closest(".chat-message")
          : null;
        if (!messageEl) {
          return;
        }

        // Do NOT trigger for sidebar items or other non-chat things
        if (
          messageEl.closest &&
          messageEl.closest("#discord-online-users-sidebar, .discord-sidebar")
        ) {
          return;
        }

        let contextType = "message";
        let username = null;

        // Try to detect a username element inside this chat message.
        // We support multiple common patterns used by Discourse chat:
        //  - elements with data-user-card / data-username
        //  - typical chat username containers / mentions
        let usernameEl = null;
        if (target.closest) {
          // Try a wide set of selectors; we are already scoped to `.chat-message`
          // so a plain `.username` here should be safe to treat as the chat name.
          usernameEl = target.closest(
            "[data-user-card], [data-username], .chat-message-user, .chat-message-author, .chat-message-username, .chat-message-info .username, .username, a.mention, .mention, .chat-message-avatar"
          );
        }

        if (usernameEl) {
          contextType = "user";

          // Resolve username, preferring data attributes, with a fallback scan
          // of the whole message element so avatar clicks still get the name.
          let resolvedUsername = "";

          if (
            usernameEl.dataset &&
            (usernameEl.dataset.userCard || usernameEl.dataset.username)
          ) {
            resolvedUsername =
              usernameEl.dataset.userCard || usernameEl.dataset.username || "";
          } else {
            resolvedUsername =
              (usernameEl.textContent || "").trim().replace(/^@/, "");
          }

          // If that element had no useful text, look for a better username node
          // inside the same chat message.
          if (!resolvedUsername && messageEl) {
            const innerNameEl =
              messageEl.querySelector(
                "[data-user-card], [data-username], .chat-message-username, .chat-message-info .username, .username"
              );
            if (innerNameEl) {
              if (
                innerNameEl.dataset &&
                (innerNameEl.dataset.userCard || innerNameEl.dataset.username)
              ) {
                resolvedUsername =
                  innerNameEl.dataset.userCard ||
                  innerNameEl.dataset.username ||
                  "";
              } else {
                resolvedUsername = (
                  innerNameEl.textContent || ""
                ).trim().replace(/^@/, "");
              }
            }
          }

          username = resolvedUsername;
        }

        const msgId =
          messageEl.dataset.messageId ||
          messageEl.dataset.id ||
          messageEl.getAttribute("data-id") ||
          "";

        showChatContextMenu(e, {
          type: contextType,
          username,
          messageId: msgId,
          messageEl,
        });
      },
      true
    );

    // Separate handler: right-click on usernames in the online users sidebar
    document.addEventListener(
      "contextmenu",
      function (e) {
        const target = e.target;

        // Ignore if right-click is inside our custom menu
        if (target.closest && target.closest(".discord-chat-context-menu")) {
          return;
        }

        const userItem =
          target.closest && target.closest(".discord-user-item");
        if (!userItem) {
          return;
        }

        // Only show this user menu if chat is actually present somewhere
        const isInChat =
          document.querySelector(".chat-container, .chat-drawer, .full-page-chat") !==
          null;
        if (!isInChat) {
          return;
        }

        const uname =
          userItem.dataset.username ||
          userItem.getAttribute("data-username") ||
          (userItem.textContent || "").trim();
        if (!uname) {
          return;
        }

        showChatContextMenu(e, {
          type: "user",
          username: uname,
          messageId: "",
          messageEl: null,
        });
      },
      true
    );

    // Hide on global click / scroll / resize / escape
    document.addEventListener(
      "click",
      function (e) {
        if (
          e.target &&
          e.target.closest &&
          e.target.closest(".discord-chat-context-menu")
        ) {
          return;
        }
        hideChatContextMenu();
      },
      true
    );

    document.addEventListener(
      "keydown",
      function (e) {
        if (e.key === "Escape") {
          hideChatContextMenu();
        }
      },
      true
    );

    window.addEventListener("scroll", hideChatContextMenu, true);
    window.addEventListener("resize", hideChatContextMenu, true);
  }

  // Initialize chat context menu once; it will only react inside chat areas
  setupChatContextMenu();

  if (isMobile) {
    createMobileDrawer();
    setupMobileDrawerGestures();
  } else {
    createSidebar();
  }

  // Initialize chat context menu once; it will only react inside chat areas
  setupChatContextMenu();

  if (isMobile) {
    createMobileDrawer();
    setupMobileDrawerGestures();
  } else {
    createSidebar();
  }

  // After initial render of chat + sidebar, sync note icons
  refreshUserNoteIndicators();
  setupUserNoteObserver();

  if (fetchTimer) clearInterval(fetchTimer);
  fetchTimer = setInterval(updateOnlineStatus, refreshInterval);
});
</script>
